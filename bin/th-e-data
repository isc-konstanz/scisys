#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
    th-e-data
    ~~~~~~~~~

    To learn how to configure the processing of timeseries, see "th-e-data --help"

"""
from __future__ import annotations

import os
import shutil
import pytz as tz
import pandas as pd
import datetime as dt

from typing import Any, List
from argparse import ArgumentParser, RawTextHelpFormatter
from th_e_core import Configurations, System


def main(args: List[Any]) -> None:
    setting_args = vars(args)
    action = setting_args.pop('action')

    settings = Configurations('settings.cfg', **setting_args)
    setting_args.update(settings.general)

    systems = System.read(**setting_args)
    if action == 'build':
        systems.build(**setting_args)
    elif action == 'process':
        for system in systems:
            process(system, **setting_args)


def process(system: System,
            data_dir: str = 'data',
            start: str | dt.datetime = dt.datetime(1970, 1, 1, tzinfo=tz.UTC),
            end: str | dt.datetime = None, **kwargs) -> None:
    from th_e_core.tools import ceil_date, resample_data
    from th_e_core.io.csv import CsvDatabase
    from th_e_data.process import process

    start = _get_date(start, system.location.timezone)
    end = _get_date(end, system.location.timezone)
    if end is not None:
        end = ceil_date(end, system.location.timezone)

    if not os.path.exists(data_dir):
        os.makedirs(data_dir)
    data_file = os.path.join(data_dir, system.id)
    data = system.database.read(start, end)

    try:
        import sqlite3 as sqlite
        data.to_sql(system.name, sqlite.connect(data_file + '_raw.sqlite'), if_exists='replace')

    except Exception as e:
        logger.warning("unable to write data as SQLite file: " + str(e))

    database = CsvDatabase(timezone=system.location.timezone)
    database.write(data, file=data_file + '_raw.csv')

    resolution = int(kwargs.pop('resolution', '1'))
    processed = process(data, resolution, **kwargs)
    database.write(processed, file=data_file + '_{}m.csv'.format(resolution))
    for resolution in [15, 60]:
        resampled = resample_data(processed, resolution*60)
        database.write(resampled, file=data_file + '_{}m.csv'.format(resolution))


def _get_date(time: str | dt.datetime, timezone: tz.timezone) -> pd.Timestamp:
    if isinstance(time, str):
        return pd.Timestamp(timezone.localize(dt.datetime.strptime(time, '%d.%m.%Y')))
    if time is not None and time.tzinfo is not None and time.tzinfo.utcoffset(time) is not None:
        time = time.astimezone(timezone)
    return time


def _get_parser(root_dir: str) -> ArgumentParser:
    from th_e_core import __version__

    parser = ArgumentParser(description=__doc__, formatter_class=RawTextHelpFormatter)
    parser.add_argument('-v', '--version',
                        action='version',
                        version='%(prog)s {version}'.format(version=__version__))

    subparsers = parser.add_subparsers(dest='action')
    subparsers.required = True
    subparsers.add_parser('build', help='Build data for the configured set of systems')
    subparsers.add_parser('process', help='Processes data for the configured set of systems')

    parser.add_argument('-r', '--root-directory',
                        dest='root_dir',
                        help="directory where the package and related libraries are located",
                        default=root_dir,
                        metavar='DIR')

    parser.add_argument('-c', '--config-directory',
                        dest='config_dir',
                        help="directory to expect configuration files",
                        default='conf',
                        metavar='DIR')

    parser.add_argument('-d', '--data-directory',
                        dest='data_dir',
                        help="directory to expect and write result files to",
                        default='data',
                        metavar='DIR')

    return parser


if __name__ == "__main__":
    run_dir = os.getcwd()
    if os.path.basename(run_dir) == 'bin':
        run_dir = os.path.dirname(run_dir)

    os.chdir(run_dir)

    os.environ['NUMEXPR_MAX_THREADS'] = str(os.cpu_count())

    if not os.path.exists('log'):
        os.makedirs('log')

    logging_file = os.path.join(os.path.join(run_dir, 'conf'), 'logging.cfg')
    if not os.path.isfile(logging_file):
        logging_default = logging_file.replace('logging.cfg', 'logging.default.cfg')
        if os.path.isfile(logging_default):
            shutil.copy(logging_default, logging_file)
        else:
            raise FileNotFoundError("Unable to open logging.cfg in: " +
                                    os.path.join(os.path.join(run_dir, 'conf')))

    # Load the logging configuration
    import logging
    import logging.config

    logging.config.fileConfig(logging_file)
    logger = logging.getLogger('th-e-data')

    main(_get_parser(run_dir).parse_args())
